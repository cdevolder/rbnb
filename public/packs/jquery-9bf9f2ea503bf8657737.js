/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/packs/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ({

/***/ 4:
/*!****************************************************!*\
  !*** ./app/javascript/packs/jquery.geocomplete.js ***!
  \****************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("/**\n * jQuery Geocoding and Places Autocomplete Plugin - V 1.7.0\n *\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2016\n * @author Ubilabs http://ubilabs.net, 2016\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\n// # $.geocomplete()\n// ## jQuery Geocoding and Places Autocomplete Plugin\n//\n// * https://github.com/ubilabs/geocomplete/\n// * by Martin Kleppe <kleppe@ubilabs.net>\n\n(function ($, window, document, undefined) {\n\n  // ## Options\n  // The default options for this plugin.\n  //\n  // * `map` - Might be a selector, an jQuery object or a DOM element. Default is `false` which shows no map.\n  // * `details` - The container that should be populated with data. Defaults to `false` which ignores the setting.\n  // * 'detailsScope' - Allows you to scope the 'details' container and have multiple geocomplete fields on one page. Must be a parent of the input. Default is 'null'\n  // * `location` - Location to initialize the map on. Might be an address `string` or an `array` with [latitude, longitude] or a `google.maps.LatLng`object. Default is `false` which shows a blank map.\n  // * `bounds` - Whether to snap geocode search to map bounds. Default: `true` if false search globally. Alternatively pass a custom `LatLngBounds object.\n  // * `autoselect` - Automatically selects the highlighted item or the first item from the suggestions list on Enter.\n  // * `detailsAttribute` - The attribute's name to use as an indicator. Default: `\"name\"`\n  // * `mapOptions` - Options to pass to the `google.maps.Map` constructor. See the full list [here](http://code.google.com/apis/maps/documentation/javascript/reference.html#MapOptions).\n  // * `mapOptions.zoom` - The inital zoom level. Default: `14`\n  // * `mapOptions.scrollwheel` - Whether to enable the scrollwheel to zoom the map. Default: `false`\n  // * `mapOptions.mapTypeId` - The map type. Default: `\"roadmap\"`\n  // * `markerOptions` - The options to pass to the `google.maps.Marker` constructor. See the full list [here](http://code.google.com/apis/maps/documentation/javascript/reference.html#MarkerOptions).\n  // * `markerOptions.draggable` - If the marker is draggable. Default: `false`. Set to true to enable dragging.\n  // * `markerOptions.disabled` - Do not show marker. Default: `false`. Set to true to disable marker.\n  // * `maxZoom` - The maximum zoom level too zoom in after a geocoding response. Default: `16`\n  // * `types` - An array containing one or more of the supported types for the places request. Default: `['geocode']` See the full list [here](http://code.google.com/apis/maps/documentation/javascript/places.html#place_search_requests).\n  // * `blur` - Trigger geocode when input loses focus.\n  // * `geocodeAfterResult` - If blur is set to true, choose whether to geocode if user has explicitly selected a result before blur.\n  // * `restoreValueAfterBlur` - Restores the input's value upon blurring. Default is `false` which ignores the setting.\n\n  var defaults = {\n    bounds: true,\n    strictBounds: false,\n    country: null,\n    map: false,\n    details: false,\n    detailsAttribute: \"name\",\n    detailsScope: null,\n    autoselect: true,\n    location: false,\n\n    mapOptions: {\n      zoom: 14,\n      scrollwheel: false,\n      mapTypeId: \"roadmap\"\n    },\n\n    markerOptions: {\n      draggable: false\n    },\n\n    maxZoom: 16,\n    types: ['geocode'],\n    blur: false,\n    geocodeAfterResult: false,\n    restoreValueAfterBlur: false\n  };\n\n  // See: [Geocoding Types](https://developers.google.com/maps/documentation/geocoding/#Types)\n  // on Google Developers.\n  var componentTypes = (\"street_address route intersection political \" + \"country administrative_area_level_1 administrative_area_level_2 \" + \"administrative_area_level_3 colloquial_area locality sublocality \" + \"neighborhood premise subpremise postal_code natural_feature airport \" + \"park point_of_interest post_box street_number floor room \" + \"lat lng viewport location \" + \"formatted_address location_type bounds\").split(\" \");\n\n  // See: [Places Details Responses](https://developers.google.com/maps/documentation/javascript/places#place_details_responses)\n  // on Google Developers.\n  var placesDetails = (\"id place_id url website vicinity reference name rating \" + \"international_phone_number icon formatted_phone_number\").split(\" \");\n\n  // The actual plugin constructor.\n  function GeoComplete(input, options) {\n\n    this.options = $.extend(true, {}, defaults, options);\n\n    // This is a fix to allow types:[] not to be overridden by defaults\n    // so search results includes everything\n    if (options && options.types) {\n      this.options.types = options.types;\n    }\n\n    this.input = input;\n    this.$input = $(input);\n\n    this._defaults = defaults;\n    this._name = 'geocomplete';\n\n    this.init();\n  }\n\n  // Initialize all parts of the plugin.\n  $.extend(GeoComplete.prototype, {\n    init: function init() {\n      this.initMap();\n      this.initMarker();\n      this.initGeocoder();\n      this.initDetails();\n      this.initLocation();\n    },\n\n    // Initialize the map but only if the option `map` was set.\n    // This will create a `map` within the given container\n    // using the provided `mapOptions` or link to the existing map instance.\n    initMap: function initMap() {\n      if (!this.options.map) {\n        return;\n      }\n\n      if (typeof this.options.map.setCenter == \"function\") {\n        this.map = this.options.map;\n        return;\n      }\n\n      this.map = new google.maps.Map($(this.options.map)[0], this.options.mapOptions);\n\n      // add click event listener on the map\n      google.maps.event.addListener(this.map, 'click', $.proxy(this.mapClicked, this));\n\n      // add dragend even listener on the map\n      google.maps.event.addListener(this.map, 'dragend', $.proxy(this.mapDragged, this));\n\n      // add idle even listener on the map\n      google.maps.event.addListener(this.map, 'idle', $.proxy(this.mapIdle, this));\n\n      google.maps.event.addListener(this.map, 'zoom_changed', $.proxy(this.mapZoomed, this));\n    },\n\n    // Add a marker with the provided `markerOptions` but only\n    // if the option was set. Additionally it listens for the `dragend` event\n    // to notify the plugin about changes.\n    initMarker: function initMarker() {\n      if (!this.map) {\n        return;\n      }\n      var options = $.extend(this.options.markerOptions, { map: this.map });\n\n      if (options.disabled) {\n        return;\n      }\n\n      this.marker = new google.maps.Marker(options);\n\n      google.maps.event.addListener(this.marker, 'dragend', $.proxy(this.markerDragged, this));\n    },\n\n    // Associate the input with the autocompleter and create a geocoder\n    // to fall back when the autocompleter does not return a value.\n    initGeocoder: function initGeocoder() {\n\n      // Indicates is user did select a result from the dropdown.\n      var selected = false;\n\n      var options = {\n        types: this.options.types,\n        bounds: this.options.bounds === true ? null : this.options.bounds,\n        componentRestrictions: this.options.componentRestrictions,\n        strictBounds: this.options.strictBounds\n      };\n\n      if (this.options.country) {\n        options.componentRestrictions = { country: this.options.country };\n      }\n\n      this.autocomplete = new google.maps.places.Autocomplete(this.input, options);\n\n      this.geocoder = new google.maps.Geocoder();\n\n      // Bind autocomplete to map bounds but only if there is a map\n      // and `options.bindToMap` is set to true.\n      if (this.map && this.options.bounds === true) {\n        this.autocomplete.bindTo('bounds', this.map);\n      }\n\n      // Watch `place_changed` events on the autocomplete input field.\n      google.maps.event.addListener(this.autocomplete, 'place_changed', $.proxy(this.placeChanged, this));\n\n      // Prevent parent form from being submitted if user hit enter.\n      this.$input.on('keypress.' + this._name, function (event) {\n        if (event.keyCode === 13) {\n          return false;\n        }\n      });\n\n      // Assume that if user types anything after having selected a result,\n      // the selected location is not valid any more.\n      if (this.options.geocodeAfterResult === true) {\n        this.$input.bind('keypress.' + this._name, $.proxy(function () {\n          if (event.keyCode != 9 && this.selected === true) {\n            this.selected = false;\n          }\n        }, this));\n      }\n\n      // Listen for \"geocode\" events and trigger find action.\n      this.$input.bind('geocode.' + this._name, $.proxy(function () {\n        this.find();\n      }, this));\n\n      // Saves the previous input value\n      this.$input.bind('geocode:result.' + this._name, $.proxy(function () {\n        this.lastInputVal = this.$input.val();\n      }, this));\n\n      // Trigger find action when input element is blurred out and user has\n      // not explicitly selected a result.\n      // (Useful for typing partial location and tabbing to the next field\n      // or clicking somewhere else.)\n      if (this.options.blur === true) {\n        this.$input.on('blur.' + this._name, $.proxy(function () {\n          if (this.options.geocodeAfterResult === true && this.selected === true) {\n            return;\n          }\n\n          if (this.options.restoreValueAfterBlur === true && this.selected === true) {\n            setTimeout($.proxy(this.restoreLastValue, this), 0);\n          } else {\n            this.find();\n          }\n        }, this));\n      }\n    },\n\n    // Prepare a given DOM structure to be populated when we got some data.\n    // This will cycle through the list of component types and map the\n    // corresponding elements.\n    initDetails: function initDetails() {\n      if (!this.options.details) {\n        return;\n      }\n\n      if (this.options.detailsScope) {\n        var $details = $(this.input).parents(this.options.detailsScope).find(this.options.details);\n      } else {\n        var $details = $(this.options.details);\n      }\n\n      var attribute = this.options.detailsAttribute,\n          details = {};\n\n      function setDetail(value) {\n        details[value] = $details.find(\"[\" + attribute + \"=\" + value + \"]\");\n      }\n\n      $.each(componentTypes, function (index, key) {\n        setDetail(key);\n        setDetail(key + \"_short\");\n      });\n\n      $.each(placesDetails, function (index, key) {\n        setDetail(key);\n      });\n\n      this.$details = $details;\n      this.details = details;\n    },\n\n    // Set the initial location of the plugin if the `location` options was set.\n    // This method will care about converting the value into the right format.\n    initLocation: function initLocation() {\n\n      var location = this.options.location,\n          latLng;\n\n      if (!location) {\n        return;\n      }\n\n      if (typeof location == 'string') {\n        this.find(location);\n        return;\n      }\n\n      if (location instanceof Array) {\n        latLng = new google.maps.LatLng(location[0], location[1]);\n      }\n\n      if (location instanceof google.maps.LatLng) {\n        latLng = location;\n      }\n\n      if (latLng) {\n        if (this.map) {\n          this.map.setCenter(latLng);\n        }\n        if (this.marker) {\n          this.marker.setPosition(latLng);\n        }\n      }\n    },\n\n    destroy: function destroy() {\n      if (this.map) {\n        google.maps.event.clearInstanceListeners(this.map);\n        google.maps.event.clearInstanceListeners(this.marker);\n      }\n\n      this.autocomplete.unbindAll();\n      google.maps.event.clearInstanceListeners(this.autocomplete);\n      google.maps.event.clearInstanceListeners(this.input);\n      this.$input.removeData();\n      this.$input.off(this._name);\n      this.$input.unbind('.' + this._name);\n    },\n\n    // Look up a given address. If no `address` was specified it uses\n    // the current value of the input.\n    find: function find(address) {\n      this.geocode({\n        address: address || this.$input.val()\n      });\n    },\n\n    // Requests details about a given location.\n    // Additionally it will bias the requests to the provided bounds.\n    geocode: function geocode(request) {\n      // Don't geocode if the requested address is empty\n      if (!request.address) {\n        return;\n      }\n      if (this.options.bounds && !request.bounds) {\n        if (this.options.bounds === true) {\n          request.bounds = this.map && this.map.getBounds();\n        } else {\n          request.bounds = this.options.bounds;\n        }\n      }\n\n      if (this.options.country) {\n        request.region = this.options.country;\n      }\n\n      this.geocoder.geocode(request, $.proxy(this.handleGeocode, this));\n    },\n\n    // Get the selected result. If no result is selected on the list, then get\n    // the first result from the list.\n    selectFirstResult: function selectFirstResult() {\n      //$(\".pac-container\").hide();\n\n      var selected = '';\n      // Check if any result is selected.\n      if ($(\".pac-item-selected\")[0]) {\n        selected = '-selected';\n      }\n\n      // Get the first suggestion's text.\n      var $span1 = $(\".pac-container:visible .pac-item\" + selected + \":first span:nth-child(2)\").text();\n      var $span2 = $(\".pac-container:visible .pac-item\" + selected + \":first span:nth-child(3)\").text();\n\n      // Adds the additional information, if available.\n      var firstResult = $span1;\n      if ($span2) {\n        firstResult += \" - \" + $span2;\n      }\n\n      this.$input.val(firstResult);\n\n      return firstResult;\n    },\n\n    // Restores the input value using the previous value if it exists\n    restoreLastValue: function restoreLastValue() {\n      if (this.lastInputVal) {\n        this.$input.val(this.lastInputVal);\n      }\n    },\n\n    // Handles the geocode response. If more than one results was found\n    // it triggers the \"geocode:multiple\" events. If there was an error\n    // the \"geocode:error\" event is fired.\n    handleGeocode: function handleGeocode(results, status) {\n      if (status === google.maps.GeocoderStatus.OK) {\n        var result = results[0];\n        this.$input.val(result.formatted_address);\n        this.update(result);\n\n        if (results.length > 1) {\n          this.trigger(\"geocode:multiple\", results);\n        }\n      } else {\n        this.trigger(\"geocode:error\", status);\n      }\n    },\n\n    // Triggers a given `event` with optional `arguments` on the input.\n    trigger: function trigger(event, argument) {\n      this.$input.trigger(event, [argument]);\n    },\n\n    // Set the map to a new center by passing a `geometry`.\n    // If the geometry has a viewport, the map zooms out to fit the bounds.\n    // Additionally it updates the marker position.\n    center: function center(geometry) {\n      if (geometry.viewport) {\n        this.map.fitBounds(geometry.viewport);\n        if (this.map.getZoom() > this.options.maxZoom) {\n          this.map.setZoom(this.options.maxZoom);\n        }\n      } else {\n        this.map.setZoom(this.options.maxZoom);\n        this.map.setCenter(geometry.location);\n      }\n\n      if (this.marker) {\n        this.marker.setPosition(geometry.location);\n        this.marker.setAnimation(this.options.markerOptions.animation);\n      }\n    },\n\n    // Update the elements based on a single places or geocoding response\n    // and trigger the \"geocode:result\" event on the input.\n    update: function update(result) {\n\n      if (this.map) {\n        this.center(result.geometry);\n      }\n\n      if (this.$details) {\n        this.fillDetails(result);\n      }\n\n      this.trigger(\"geocode:result\", result);\n    },\n\n    // Populate the provided elements with new `result` data.\n    // This will lookup all elements that has an attribute with the given\n    // component type.\n    fillDetails: function fillDetails(result) {\n\n      var data = {},\n          geometry = result.geometry,\n          viewport = geometry.viewport,\n          bounds = geometry.bounds;\n\n      // Create a simplified version of the address components.\n      $.each(result.address_components, function (index, object) {\n        var name = object.types[0];\n\n        $.each(object.types, function (index, name) {\n          data[name] = object.long_name;\n          data[name + \"_short\"] = object.short_name;\n        });\n      });\n\n      // Add properties of the places details.\n      $.each(placesDetails, function (index, key) {\n        data[key] = result[key];\n      });\n\n      // Add infos about the address and geometry.\n      $.extend(data, {\n        formatted_address: result.formatted_address,\n        location_type: geometry.location_type || \"PLACES\",\n        viewport: viewport,\n        bounds: bounds,\n        location: geometry.location,\n        lat: geometry.location.lat(),\n        lng: geometry.location.lng()\n      });\n\n      // Set the values for all details.\n      $.each(this.details, $.proxy(function (key, $detail) {\n        var value = data[key];\n        this.setDetail($detail, value);\n      }, this));\n\n      this.data = data;\n    },\n\n    // Assign a given `value` to a single `$element`.\n    // If the element is an input, the value is set, otherwise it updates\n    // the text content.\n    setDetail: function setDetail($element, value) {\n\n      if (value === undefined) {\n        value = \"\";\n      } else if (typeof value.toUrlValue == \"function\") {\n        value = value.toUrlValue();\n      }\n\n      if ($element.is(\":input\")) {\n        $element.val(value);\n      } else {\n        $element.text(value);\n      }\n    },\n\n    // Fire the \"geocode:dragged\" event and pass the new position.\n    markerDragged: function markerDragged(event) {\n      this.trigger(\"geocode:dragged\", event.latLng);\n    },\n\n    mapClicked: function mapClicked(event) {\n      this.trigger(\"geocode:click\", event.latLng);\n    },\n\n    // Fire the \"geocode:mapdragged\" event and pass the current position of the map center.\n    mapDragged: function mapDragged(event) {\n      this.trigger(\"geocode:mapdragged\", this.map.getCenter());\n    },\n\n    // Fire the \"geocode:idle\" event and pass the current position of the map center.\n    mapIdle: function mapIdle(event) {\n      this.trigger(\"geocode:idle\", this.map.getCenter());\n    },\n\n    mapZoomed: function mapZoomed(event) {\n      this.trigger(\"geocode:zoom\", this.map.getZoom());\n    },\n\n    // Restore the old position of the marker to the last knwon location.\n    resetMarker: function resetMarker() {\n      this.marker.setPosition(this.data.location);\n      this.setDetail(this.details.lat, this.data.location.lat());\n      this.setDetail(this.details.lng, this.data.location.lng());\n    },\n\n    // Update the plugin after the user has selected an autocomplete entry.\n    // If the place has no geometry it passes it to the geocoder.\n    placeChanged: function placeChanged() {\n      var place = this.autocomplete.getPlace();\n      this.selected = true;\n\n      if (!place.geometry) {\n        if (this.options.autoselect) {\n          // Automatically selects the highlighted item or the first item from the\n          // suggestions list.\n          var autoSelection = this.selectFirstResult();\n          this.find(autoSelection);\n        }\n      } else {\n        // Use the input text if it already gives geometry.\n        this.update(place);\n      }\n    }\n  });\n\n  // A plugin wrapper around the constructor.\n  // Pass `options` with all settings that are different from the default.\n  // The attribute is used to prevent multiple instantiations of the plugin.\n  $.fn.geocomplete = function (options) {\n\n    var attribute = 'plugin_geocomplete';\n\n    // If you call `.geocomplete()` with a string as the first parameter\n    // it returns the corresponding property or calls the method with the\n    // following arguments.\n    if (typeof options == \"string\") {\n\n      var instance = $(this).data(attribute) || $(this).geocomplete().data(attribute),\n          prop = instance[options];\n\n      if (typeof prop == \"function\") {\n        prop.apply(instance, Array.prototype.slice.call(arguments, 1));\n        return $(this);\n      } else {\n        if (arguments.length == 2) {\n          prop = arguments[1];\n        }\n        return prop;\n      }\n    } else {\n      return this.each(function () {\n        // Prevent against multiple instantiations.\n        var instance = $.data(this, attribute);\n        if (!instance) {\n          instance = new GeoComplete(this, options);\n          $.data(this, attribute, instance);\n        }\n      });\n    }\n  };\n})(jQuery, window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC9qYXZhc2NyaXB0L3BhY2tzL2pxdWVyeS5nZW9jb21wbGV0ZS5qcz81MmYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogalF1ZXJ5IEdlb2NvZGluZyBhbmQgUGxhY2VzIEF1dG9jb21wbGV0ZSBQbHVnaW4gLSBWIDEuNy4wXG4gKlxuICogQGF1dGhvciBNYXJ0aW4gS2xlcHBlIDxrbGVwcGVAdWJpbGFicy5uZXQ+LCAyMDE2XG4gKiBAYXV0aG9yIFViaWxhYnMgaHR0cDovL3ViaWxhYnMubmV0LCAyMDE2XG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSA8aHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHA+XG4gKi9cblxuLy8gIyAkLmdlb2NvbXBsZXRlKClcbi8vICMjIGpRdWVyeSBHZW9jb2RpbmcgYW5kIFBsYWNlcyBBdXRvY29tcGxldGUgUGx1Z2luXG4vL1xuLy8gKiBodHRwczovL2dpdGh1Yi5jb20vdWJpbGFicy9nZW9jb21wbGV0ZS9cbi8vICogYnkgTWFydGluIEtsZXBwZSA8a2xlcHBlQHViaWxhYnMubmV0PlxuXG4oZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG4gIC8vICMjIE9wdGlvbnNcbiAgLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBwbHVnaW4uXG4gIC8vXG4gIC8vICogYG1hcGAgLSBNaWdodCBiZSBhIHNlbGVjdG9yLCBhbiBqUXVlcnkgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQuIERlZmF1bHQgaXMgYGZhbHNlYCB3aGljaCBzaG93cyBubyBtYXAuXG4gIC8vICogYGRldGFpbHNgIC0gVGhlIGNvbnRhaW5lciB0aGF0IHNob3VsZCBiZSBwb3B1bGF0ZWQgd2l0aCBkYXRhLiBEZWZhdWx0cyB0byBgZmFsc2VgIHdoaWNoIGlnbm9yZXMgdGhlIHNldHRpbmcuXG4gIC8vICogJ2RldGFpbHNTY29wZScgLSBBbGxvd3MgeW91IHRvIHNjb3BlIHRoZSAnZGV0YWlscycgY29udGFpbmVyIGFuZCBoYXZlIG11bHRpcGxlIGdlb2NvbXBsZXRlIGZpZWxkcyBvbiBvbmUgcGFnZS4gTXVzdCBiZSBhIHBhcmVudCBvZiB0aGUgaW5wdXQuIERlZmF1bHQgaXMgJ251bGwnXG4gIC8vICogYGxvY2F0aW9uYCAtIExvY2F0aW9uIHRvIGluaXRpYWxpemUgdGhlIG1hcCBvbi4gTWlnaHQgYmUgYW4gYWRkcmVzcyBgc3RyaW5nYCBvciBhbiBgYXJyYXlgIHdpdGggW2xhdGl0dWRlLCBsb25naXR1ZGVdIG9yIGEgYGdvb2dsZS5tYXBzLkxhdExuZ2BvYmplY3QuIERlZmF1bHQgaXMgYGZhbHNlYCB3aGljaCBzaG93cyBhIGJsYW5rIG1hcC5cbiAgLy8gKiBgYm91bmRzYCAtIFdoZXRoZXIgdG8gc25hcCBnZW9jb2RlIHNlYXJjaCB0byBtYXAgYm91bmRzLiBEZWZhdWx0OiBgdHJ1ZWAgaWYgZmFsc2Ugc2VhcmNoIGdsb2JhbGx5LiBBbHRlcm5hdGl2ZWx5IHBhc3MgYSBjdXN0b20gYExhdExuZ0JvdW5kcyBvYmplY3QuXG4gIC8vICogYGF1dG9zZWxlY3RgIC0gQXV0b21hdGljYWxseSBzZWxlY3RzIHRoZSBoaWdobGlnaHRlZCBpdGVtIG9yIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIHN1Z2dlc3Rpb25zIGxpc3Qgb24gRW50ZXIuXG4gIC8vICogYGRldGFpbHNBdHRyaWJ1dGVgIC0gVGhlIGF0dHJpYnV0ZSdzIG5hbWUgdG8gdXNlIGFzIGFuIGluZGljYXRvci4gRGVmYXVsdDogYFwibmFtZVwiYFxuICAvLyAqIGBtYXBPcHRpb25zYCAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgYGdvb2dsZS5tYXBzLk1hcGAgY29uc3RydWN0b3IuIFNlZSB0aGUgZnVsbCBsaXN0IFtoZXJlXShodHRwOi8vY29kZS5nb29nbGUuY29tL2FwaXMvbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlLmh0bWwjTWFwT3B0aW9ucykuXG4gIC8vICogYG1hcE9wdGlvbnMuem9vbWAgLSBUaGUgaW5pdGFsIHpvb20gbGV2ZWwuIERlZmF1bHQ6IGAxNGBcbiAgLy8gKiBgbWFwT3B0aW9ucy5zY3JvbGx3aGVlbGAgLSBXaGV0aGVyIHRvIGVuYWJsZSB0aGUgc2Nyb2xsd2hlZWwgdG8gem9vbSB0aGUgbWFwLiBEZWZhdWx0OiBgZmFsc2VgXG4gIC8vICogYG1hcE9wdGlvbnMubWFwVHlwZUlkYCAtIFRoZSBtYXAgdHlwZS4gRGVmYXVsdDogYFwicm9hZG1hcFwiYFxuICAvLyAqIGBtYXJrZXJPcHRpb25zYCAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGBnb29nbGUubWFwcy5NYXJrZXJgIGNvbnN0cnVjdG9yLiBTZWUgdGhlIGZ1bGwgbGlzdCBbaGVyZV0oaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9hcGlzL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZS5odG1sI01hcmtlck9wdGlvbnMpLlxuICAvLyAqIGBtYXJrZXJPcHRpb25zLmRyYWdnYWJsZWAgLSBJZiB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZS4gRGVmYXVsdDogYGZhbHNlYC4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIGRyYWdnaW5nLlxuICAvLyAqIGBtYXJrZXJPcHRpb25zLmRpc2FibGVkYCAtIERvIG5vdCBzaG93IG1hcmtlci4gRGVmYXVsdDogYGZhbHNlYC4gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBtYXJrZXIuXG4gIC8vICogYG1heFpvb21gIC0gVGhlIG1heGltdW0gem9vbSBsZXZlbCB0b28gem9vbSBpbiBhZnRlciBhIGdlb2NvZGluZyByZXNwb25zZS4gRGVmYXVsdDogYDE2YFxuICAvLyAqIGB0eXBlc2AgLSBBbiBhcnJheSBjb250YWluaW5nIG9uZSBvciBtb3JlIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgZm9yIHRoZSBwbGFjZXMgcmVxdWVzdC4gRGVmYXVsdDogYFsnZ2VvY29kZSddYCBTZWUgdGhlIGZ1bGwgbGlzdCBbaGVyZV0oaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9hcGlzL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3BsYWNlcy5odG1sI3BsYWNlX3NlYXJjaF9yZXF1ZXN0cykuXG4gIC8vICogYGJsdXJgIC0gVHJpZ2dlciBnZW9jb2RlIHdoZW4gaW5wdXQgbG9zZXMgZm9jdXMuXG4gIC8vICogYGdlb2NvZGVBZnRlclJlc3VsdGAgLSBJZiBibHVyIGlzIHNldCB0byB0cnVlLCBjaG9vc2Ugd2hldGhlciB0byBnZW9jb2RlIGlmIHVzZXIgaGFzIGV4cGxpY2l0bHkgc2VsZWN0ZWQgYSByZXN1bHQgYmVmb3JlIGJsdXIuXG4gIC8vICogYHJlc3RvcmVWYWx1ZUFmdGVyQmx1cmAgLSBSZXN0b3JlcyB0aGUgaW5wdXQncyB2YWx1ZSB1cG9uIGJsdXJyaW5nLiBEZWZhdWx0IGlzIGBmYWxzZWAgd2hpY2ggaWdub3JlcyB0aGUgc2V0dGluZy5cblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYm91bmRzOiB0cnVlLFxuICAgIHN0cmljdEJvdW5kczogZmFsc2UsXG4gICAgY291bnRyeTogbnVsbCxcbiAgICBtYXA6IGZhbHNlLFxuICAgIGRldGFpbHM6IGZhbHNlLFxuICAgIGRldGFpbHNBdHRyaWJ1dGU6IFwibmFtZVwiLFxuICAgIGRldGFpbHNTY29wZTogbnVsbCxcbiAgICBhdXRvc2VsZWN0OiB0cnVlLFxuICAgIGxvY2F0aW9uOiBmYWxzZSxcblxuICAgIG1hcE9wdGlvbnM6IHtcbiAgICAgIHpvb206IDE0LFxuICAgICAgc2Nyb2xsd2hlZWw6IGZhbHNlLFxuICAgICAgbWFwVHlwZUlkOiBcInJvYWRtYXBcIlxuICAgIH0sXG5cbiAgICBtYXJrZXJPcHRpb25zOiB7XG4gICAgICBkcmFnZ2FibGU6IGZhbHNlXG4gICAgfSxcblxuICAgIG1heFpvb206IDE2LFxuICAgIHR5cGVzOiBbJ2dlb2NvZGUnXSxcbiAgICBibHVyOiBmYWxzZSxcbiAgICBnZW9jb2RlQWZ0ZXJSZXN1bHQ6IGZhbHNlLFxuICAgIHJlc3RvcmVWYWx1ZUFmdGVyQmx1cjogZmFsc2VcbiAgfTtcblxuICAvLyBTZWU6IFtHZW9jb2RpbmcgVHlwZXNdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9nZW9jb2RpbmcvI1R5cGVzKVxuICAvLyBvbiBHb29nbGUgRGV2ZWxvcGVycy5cbiAgdmFyIGNvbXBvbmVudFR5cGVzID0gKFwic3RyZWV0X2FkZHJlc3Mgcm91dGUgaW50ZXJzZWN0aW9uIHBvbGl0aWNhbCBcIiArIFwiY291bnRyeSBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzEgYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8yIFwiICsgXCJhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzMgY29sbG9xdWlhbF9hcmVhIGxvY2FsaXR5IHN1YmxvY2FsaXR5IFwiICsgXCJuZWlnaGJvcmhvb2QgcHJlbWlzZSBzdWJwcmVtaXNlIHBvc3RhbF9jb2RlIG5hdHVyYWxfZmVhdHVyZSBhaXJwb3J0IFwiICsgXCJwYXJrIHBvaW50X29mX2ludGVyZXN0IHBvc3RfYm94IHN0cmVldF9udW1iZXIgZmxvb3Igcm9vbSBcIiArIFwibGF0IGxuZyB2aWV3cG9ydCBsb2NhdGlvbiBcIiArIFwiZm9ybWF0dGVkX2FkZHJlc3MgbG9jYXRpb25fdHlwZSBib3VuZHNcIikuc3BsaXQoXCIgXCIpO1xuXG4gIC8vIFNlZTogW1BsYWNlcyBEZXRhaWxzIFJlc3BvbnNlc10oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcGxhY2VzI3BsYWNlX2RldGFpbHNfcmVzcG9uc2VzKVxuICAvLyBvbiBHb29nbGUgRGV2ZWxvcGVycy5cbiAgdmFyIHBsYWNlc0RldGFpbHMgPSAoXCJpZCBwbGFjZV9pZCB1cmwgd2Vic2l0ZSB2aWNpbml0eSByZWZlcmVuY2UgbmFtZSByYXRpbmcgXCIgKyBcImludGVybmF0aW9uYWxfcGhvbmVfbnVtYmVyIGljb24gZm9ybWF0dGVkX3Bob25lX251bWJlclwiKS5zcGxpdChcIiBcIik7XG5cbiAgLy8gVGhlIGFjdHVhbCBwbHVnaW4gY29uc3RydWN0b3IuXG4gIGZ1bmN0aW9uIEdlb0NvbXBsZXRlKGlucHV0LCBvcHRpb25zKSB7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gVGhpcyBpcyBhIGZpeCB0byBhbGxvdyB0eXBlczpbXSBub3QgdG8gYmUgb3ZlcnJpZGRlbiBieSBkZWZhdWx0c1xuICAgIC8vIHNvIHNlYXJjaCByZXN1bHRzIGluY2x1ZGVzIGV2ZXJ5dGhpbmdcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGVzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudHlwZXMgPSBvcHRpb25zLnR5cGVzO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLiRpbnB1dCA9ICQoaW5wdXQpO1xuXG4gICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICB0aGlzLl9uYW1lID0gJ2dlb2NvbXBsZXRlJztcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBhbGwgcGFydHMgb2YgdGhlIHBsdWdpbi5cbiAgJC5leHRlbmQoR2VvQ29tcGxldGUucHJvdG90eXBlLCB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuaW5pdE1hcCgpO1xuICAgICAgdGhpcy5pbml0TWFya2VyKCk7XG4gICAgICB0aGlzLmluaXRHZW9jb2RlcigpO1xuICAgICAgdGhpcy5pbml0RGV0YWlscygpO1xuICAgICAgdGhpcy5pbml0TG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbWFwIGJ1dCBvbmx5IGlmIHRoZSBvcHRpb24gYG1hcGAgd2FzIHNldC5cbiAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgYG1hcGAgd2l0aGluIHRoZSBnaXZlbiBjb250YWluZXJcbiAgICAvLyB1c2luZyB0aGUgcHJvdmlkZWQgYG1hcE9wdGlvbnNgIG9yIGxpbmsgdG8gdGhlIGV4aXN0aW5nIG1hcCBpbnN0YW5jZS5cbiAgICBpbml0TWFwOiBmdW5jdGlvbiBpbml0TWFwKCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubWFwLnNldENlbnRlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB0aGlzLm9wdGlvbnMubWFwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcCgkKHRoaXMub3B0aW9ucy5tYXApWzBdLCB0aGlzLm9wdGlvbnMubWFwT3B0aW9ucyk7XG5cbiAgICAgIC8vIGFkZCBjbGljayBldmVudCBsaXN0ZW5lciBvbiB0aGUgbWFwXG4gICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLm1hcCwgJ2NsaWNrJywgJC5wcm94eSh0aGlzLm1hcENsaWNrZWQsIHRoaXMpKTtcblxuICAgICAgLy8gYWRkIGRyYWdlbmQgZXZlbiBsaXN0ZW5lciBvbiB0aGUgbWFwXG4gICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLm1hcCwgJ2RyYWdlbmQnLCAkLnByb3h5KHRoaXMubWFwRHJhZ2dlZCwgdGhpcykpO1xuXG4gICAgICAvLyBhZGQgaWRsZSBldmVuIGxpc3RlbmVyIG9uIHRoZSBtYXBcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMubWFwLCAnaWRsZScsICQucHJveHkodGhpcy5tYXBJZGxlLCB0aGlzKSk7XG5cbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMubWFwLCAnem9vbV9jaGFuZ2VkJywgJC5wcm94eSh0aGlzLm1hcFpvb21lZCwgdGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtYXJrZXIgd2l0aCB0aGUgcHJvdmlkZWQgYG1hcmtlck9wdGlvbnNgIGJ1dCBvbmx5XG4gICAgLy8gaWYgdGhlIG9wdGlvbiB3YXMgc2V0LiBBZGRpdGlvbmFsbHkgaXQgbGlzdGVucyBmb3IgdGhlIGBkcmFnZW5kYCBldmVudFxuICAgIC8vIHRvIG5vdGlmeSB0aGUgcGx1Z2luIGFib3V0IGNoYW5nZXMuXG4gICAgaW5pdE1hcmtlcjogZnVuY3Rpb24gaW5pdE1hcmtlcigpIHtcbiAgICAgIGlmICghdGhpcy5tYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh0aGlzLm9wdGlvbnMubWFya2VyT3B0aW9ucywgeyBtYXA6IHRoaXMubWFwIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihvcHRpb25zKTtcblxuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5tYXJrZXIsICdkcmFnZW5kJywgJC5wcm94eSh0aGlzLm1hcmtlckRyYWdnZWQsIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLy8gQXNzb2NpYXRlIHRoZSBpbnB1dCB3aXRoIHRoZSBhdXRvY29tcGxldGVyIGFuZCBjcmVhdGUgYSBnZW9jb2RlclxuICAgIC8vIHRvIGZhbGwgYmFjayB3aGVuIHRoZSBhdXRvY29tcGxldGVyIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgIGluaXRHZW9jb2RlcjogZnVuY3Rpb24gaW5pdEdlb2NvZGVyKCkge1xuXG4gICAgICAvLyBJbmRpY2F0ZXMgaXMgdXNlciBkaWQgc2VsZWN0IGEgcmVzdWx0IGZyb20gdGhlIGRyb3Bkb3duLlxuICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB0eXBlczogdGhpcy5vcHRpb25zLnR5cGVzLFxuICAgICAgICBib3VuZHM6IHRoaXMub3B0aW9ucy5ib3VuZHMgPT09IHRydWUgPyBudWxsIDogdGhpcy5vcHRpb25zLmJvdW5kcyxcbiAgICAgICAgY29tcG9uZW50UmVzdHJpY3Rpb25zOiB0aGlzLm9wdGlvbnMuY29tcG9uZW50UmVzdHJpY3Rpb25zLFxuICAgICAgICBzdHJpY3RCb3VuZHM6IHRoaXMub3B0aW9ucy5zdHJpY3RCb3VuZHNcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY291bnRyeSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudFJlc3RyaWN0aW9ucyA9IHsgY291bnRyeTogdGhpcy5vcHRpb25zLmNvdW50cnkgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZSh0aGlzLmlucHV0LCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5nZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpO1xuXG4gICAgICAvLyBCaW5kIGF1dG9jb21wbGV0ZSB0byBtYXAgYm91bmRzIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIGEgbWFwXG4gICAgICAvLyBhbmQgYG9wdGlvbnMuYmluZFRvTWFwYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgIGlmICh0aGlzLm1hcCAmJiB0aGlzLm9wdGlvbnMuYm91bmRzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLmJpbmRUbygnYm91bmRzJywgdGhpcy5tYXApO1xuICAgICAgfVxuXG4gICAgICAvLyBXYXRjaCBgcGxhY2VfY2hhbmdlZGAgZXZlbnRzIG9uIHRoZSBhdXRvY29tcGxldGUgaW5wdXQgZmllbGQuXG4gICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLmF1dG9jb21wbGV0ZSwgJ3BsYWNlX2NoYW5nZWQnLCAkLnByb3h5KHRoaXMucGxhY2VDaGFuZ2VkLCB0aGlzKSk7XG5cbiAgICAgIC8vIFByZXZlbnQgcGFyZW50IGZvcm0gZnJvbSBiZWluZyBzdWJtaXR0ZWQgaWYgdXNlciBoaXQgZW50ZXIuXG4gICAgICB0aGlzLiRpbnB1dC5vbigna2V5cHJlc3MuJyArIHRoaXMuX25hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBBc3N1bWUgdGhhdCBpZiB1c2VyIHR5cGVzIGFueXRoaW5nIGFmdGVyIGhhdmluZyBzZWxlY3RlZCBhIHJlc3VsdCxcbiAgICAgIC8vIHRoZSBzZWxlY3RlZCBsb2NhdGlvbiBpcyBub3QgdmFsaWQgYW55IG1vcmUuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdlb2NvZGVBZnRlclJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRpbnB1dC5iaW5kKCdrZXlwcmVzcy4nICsgdGhpcy5fbmFtZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT0gOSAmJiB0aGlzLnNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpc3RlbiBmb3IgXCJnZW9jb2RlXCIgZXZlbnRzIGFuZCB0cmlnZ2VyIGZpbmQgYWN0aW9uLlxuICAgICAgdGhpcy4kaW5wdXQuYmluZCgnZ2VvY29kZS4nICsgdGhpcy5fbmFtZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmluZCgpO1xuICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAvLyBTYXZlcyB0aGUgcHJldmlvdXMgaW5wdXQgdmFsdWVcbiAgICAgIHRoaXMuJGlucHV0LmJpbmQoJ2dlb2NvZGU6cmVzdWx0LicgKyB0aGlzLl9uYW1lLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0SW5wdXRWYWwgPSB0aGlzLiRpbnB1dC52YWwoKTtcbiAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgLy8gVHJpZ2dlciBmaW5kIGFjdGlvbiB3aGVuIGlucHV0IGVsZW1lbnQgaXMgYmx1cnJlZCBvdXQgYW5kIHVzZXIgaGFzXG4gICAgICAvLyBub3QgZXhwbGljaXRseSBzZWxlY3RlZCBhIHJlc3VsdC5cbiAgICAgIC8vIChVc2VmdWwgZm9yIHR5cGluZyBwYXJ0aWFsIGxvY2F0aW9uIGFuZCB0YWJiaW5nIHRvIHRoZSBuZXh0IGZpZWxkXG4gICAgICAvLyBvciBjbGlja2luZyBzb21ld2hlcmUgZWxzZS4pXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJsdXIgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kaW5wdXQub24oJ2JsdXIuJyArIHRoaXMuX25hbWUsICQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2VvY29kZUFmdGVyUmVzdWx0ID09PSB0cnVlICYmIHRoaXMuc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc3RvcmVWYWx1ZUFmdGVyQmx1ciA9PT0gdHJ1ZSAmJiB0aGlzLnNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5yZXN0b3JlTGFzdFZhbHVlLCB0aGlzKSwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcykpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBQcmVwYXJlIGEgZ2l2ZW4gRE9NIHN0cnVjdHVyZSB0byBiZSBwb3B1bGF0ZWQgd2hlbiB3ZSBnb3Qgc29tZSBkYXRhLlxuICAgIC8vIFRoaXMgd2lsbCBjeWNsZSB0aHJvdWdoIHRoZSBsaXN0IG9mIGNvbXBvbmVudCB0eXBlcyBhbmQgbWFwIHRoZVxuICAgIC8vIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMuXG4gICAgaW5pdERldGFpbHM6IGZ1bmN0aW9uIGluaXREZXRhaWxzKCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGV0YWlsc1Njb3BlKSB7XG4gICAgICAgIHZhciAkZGV0YWlscyA9ICQodGhpcy5pbnB1dCkucGFyZW50cyh0aGlzLm9wdGlvbnMuZGV0YWlsc1Njb3BlKS5maW5kKHRoaXMub3B0aW9ucy5kZXRhaWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciAkZGV0YWlscyA9ICQodGhpcy5vcHRpb25zLmRldGFpbHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmRldGFpbHNBdHRyaWJ1dGUsXG4gICAgICAgICAgZGV0YWlscyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBzZXREZXRhaWwodmFsdWUpIHtcbiAgICAgICAgZGV0YWlsc1t2YWx1ZV0gPSAkZGV0YWlscy5maW5kKFwiW1wiICsgYXR0cmlidXRlICsgXCI9XCIgKyB2YWx1ZSArIFwiXVwiKTtcbiAgICAgIH1cblxuICAgICAgJC5lYWNoKGNvbXBvbmVudFR5cGVzLCBmdW5jdGlvbiAoaW5kZXgsIGtleSkge1xuICAgICAgICBzZXREZXRhaWwoa2V5KTtcbiAgICAgICAgc2V0RGV0YWlsKGtleSArIFwiX3Nob3J0XCIpO1xuICAgICAgfSk7XG5cbiAgICAgICQuZWFjaChwbGFjZXNEZXRhaWxzLCBmdW5jdGlvbiAoaW5kZXgsIGtleSkge1xuICAgICAgICBzZXREZXRhaWwoa2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRkZXRhaWxzID0gJGRldGFpbHM7XG4gICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIGluaXRpYWwgbG9jYXRpb24gb2YgdGhlIHBsdWdpbiBpZiB0aGUgYGxvY2F0aW9uYCBvcHRpb25zIHdhcyBzZXQuXG4gICAgLy8gVGhpcyBtZXRob2Qgd2lsbCBjYXJlIGFib3V0IGNvbnZlcnRpbmcgdGhlIHZhbHVlIGludG8gdGhlIHJpZ2h0IGZvcm1hdC5cbiAgICBpbml0TG9jYXRpb246IGZ1bmN0aW9uIGluaXRMb2NhdGlvbigpIHtcblxuICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLmxvY2F0aW9uLFxuICAgICAgICAgIGxhdExuZztcblxuICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5maW5kKGxvY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9jYXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBsYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxvY2F0aW9uWzBdLCBsb2NhdGlvblsxXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykge1xuICAgICAgICBsYXRMbmcgPSBsb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhdExuZykge1xuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRDZW50ZXIobGF0TG5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICB0aGlzLm1hcmtlci5zZXRQb3NpdGlvbihsYXRMbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyh0aGlzLm1hcCk7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnModGhpcy5tYXJrZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmF1dG9jb21wbGV0ZS51bmJpbmRBbGwoKTtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnModGhpcy5hdXRvY29tcGxldGUpO1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyh0aGlzLmlucHV0KTtcbiAgICAgIHRoaXMuJGlucHV0LnJlbW92ZURhdGEoKTtcbiAgICAgIHRoaXMuJGlucHV0Lm9mZih0aGlzLl9uYW1lKTtcbiAgICAgIHRoaXMuJGlucHV0LnVuYmluZCgnLicgKyB0aGlzLl9uYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gTG9vayB1cCBhIGdpdmVuIGFkZHJlc3MuIElmIG5vIGBhZGRyZXNzYCB3YXMgc3BlY2lmaWVkIGl0IHVzZXNcbiAgICAvLyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChhZGRyZXNzKSB7XG4gICAgICB0aGlzLmdlb2NvZGUoe1xuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzIHx8IHRoaXMuJGlucHV0LnZhbCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVxdWVzdHMgZGV0YWlscyBhYm91dCBhIGdpdmVuIGxvY2F0aW9uLlxuICAgIC8vIEFkZGl0aW9uYWxseSBpdCB3aWxsIGJpYXMgdGhlIHJlcXVlc3RzIHRvIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gICAgZ2VvY29kZTogZnVuY3Rpb24gZ2VvY29kZShyZXF1ZXN0KSB7XG4gICAgICAvLyBEb24ndCBnZW9jb2RlIGlmIHRoZSByZXF1ZXN0ZWQgYWRkcmVzcyBpcyBlbXB0eVxuICAgICAgaWYgKCFyZXF1ZXN0LmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgJiYgIXJlcXVlc3QuYm91bmRzKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSB0cnVlKSB7XG4gICAgICAgICAgcmVxdWVzdC5ib3VuZHMgPSB0aGlzLm1hcCAmJiB0aGlzLm1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXF1ZXN0LmJvdW5kcyA9IHRoaXMub3B0aW9ucy5ib3VuZHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb3VudHJ5KSB7XG4gICAgICAgIHJlcXVlc3QucmVnaW9uID0gdGhpcy5vcHRpb25zLmNvdW50cnk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2VvY29kZXIuZ2VvY29kZShyZXF1ZXN0LCAkLnByb3h5KHRoaXMuaGFuZGxlR2VvY29kZSwgdGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHNlbGVjdGVkIHJlc3VsdC4gSWYgbm8gcmVzdWx0IGlzIHNlbGVjdGVkIG9uIHRoZSBsaXN0LCB0aGVuIGdldFxuICAgIC8vIHRoZSBmaXJzdCByZXN1bHQgZnJvbSB0aGUgbGlzdC5cbiAgICBzZWxlY3RGaXJzdFJlc3VsdDogZnVuY3Rpb24gc2VsZWN0Rmlyc3RSZXN1bHQoKSB7XG4gICAgICAvLyQoXCIucGFjLWNvbnRhaW5lclwiKS5oaWRlKCk7XG5cbiAgICAgIHZhciBzZWxlY3RlZCA9ICcnO1xuICAgICAgLy8gQ2hlY2sgaWYgYW55IHJlc3VsdCBpcyBzZWxlY3RlZC5cbiAgICAgIGlmICgkKFwiLnBhYy1pdGVtLXNlbGVjdGVkXCIpWzBdKSB7XG4gICAgICAgIHNlbGVjdGVkID0gJy1zZWxlY3RlZCc7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgZmlyc3Qgc3VnZ2VzdGlvbidzIHRleHQuXG4gICAgICB2YXIgJHNwYW4xID0gJChcIi5wYWMtY29udGFpbmVyOnZpc2libGUgLnBhYy1pdGVtXCIgKyBzZWxlY3RlZCArIFwiOmZpcnN0IHNwYW46bnRoLWNoaWxkKDIpXCIpLnRleHQoKTtcbiAgICAgIHZhciAkc3BhbjIgPSAkKFwiLnBhYy1jb250YWluZXI6dmlzaWJsZSAucGFjLWl0ZW1cIiArIHNlbGVjdGVkICsgXCI6Zmlyc3Qgc3BhbjpudGgtY2hpbGQoMylcIikudGV4dCgpO1xuXG4gICAgICAvLyBBZGRzIHRoZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLCBpZiBhdmFpbGFibGUuXG4gICAgICB2YXIgZmlyc3RSZXN1bHQgPSAkc3BhbjE7XG4gICAgICBpZiAoJHNwYW4yKSB7XG4gICAgICAgIGZpcnN0UmVzdWx0ICs9IFwiIC0gXCIgKyAkc3BhbjI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGlucHV0LnZhbChmaXJzdFJlc3VsdCk7XG5cbiAgICAgIHJldHVybiBmaXJzdFJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gUmVzdG9yZXMgdGhlIGlucHV0IHZhbHVlIHVzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBpZiBpdCBleGlzdHNcbiAgICByZXN0b3JlTGFzdFZhbHVlOiBmdW5jdGlvbiByZXN0b3JlTGFzdFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMubGFzdElucHV0VmFsKSB7XG4gICAgICAgIHRoaXMuJGlucHV0LnZhbCh0aGlzLmxhc3RJbnB1dFZhbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEhhbmRsZXMgdGhlIGdlb2NvZGUgcmVzcG9uc2UuIElmIG1vcmUgdGhhbiBvbmUgcmVzdWx0cyB3YXMgZm91bmRcbiAgICAvLyBpdCB0cmlnZ2VycyB0aGUgXCJnZW9jb2RlOm11bHRpcGxlXCIgZXZlbnRzLiBJZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAvLyB0aGUgXCJnZW9jb2RlOmVycm9yXCIgZXZlbnQgaXMgZmlyZWQuXG4gICAgaGFuZGxlR2VvY29kZTogZnVuY3Rpb24gaGFuZGxlR2VvY29kZShyZXN1bHRzLCBzdGF0dXMpIHtcbiAgICAgIGlmIChzdGF0dXMgPT09IGdvb2dsZS5tYXBzLkdlb2NvZGVyU3RhdHVzLk9LKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzBdO1xuICAgICAgICB0aGlzLiRpbnB1dC52YWwocmVzdWx0LmZvcm1hdHRlZF9hZGRyZXNzKTtcbiAgICAgICAgdGhpcy51cGRhdGUocmVzdWx0KTtcblxuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZ2VvY29kZTptdWx0aXBsZVwiLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwiZ2VvY29kZTplcnJvclwiLCBzdGF0dXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUcmlnZ2VycyBhIGdpdmVuIGBldmVudGAgd2l0aCBvcHRpb25hbCBgYXJndW1lbnRzYCBvbiB0aGUgaW5wdXQuXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihldmVudCwgYXJndW1lbnQpIHtcbiAgICAgIHRoaXMuJGlucHV0LnRyaWdnZXIoZXZlbnQsIFthcmd1bWVudF0pO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIG1hcCB0byBhIG5ldyBjZW50ZXIgYnkgcGFzc2luZyBhIGBnZW9tZXRyeWAuXG4gICAgLy8gSWYgdGhlIGdlb21ldHJ5IGhhcyBhIHZpZXdwb3J0LCB0aGUgbWFwIHpvb21zIG91dCB0byBmaXQgdGhlIGJvdW5kcy5cbiAgICAvLyBBZGRpdGlvbmFsbHkgaXQgdXBkYXRlcyB0aGUgbWFya2VyIHBvc2l0aW9uLlxuICAgIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKGdlb21ldHJ5KSB7XG4gICAgICBpZiAoZ2VvbWV0cnkudmlld3BvcnQpIHtcbiAgICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKGdlb21ldHJ5LnZpZXdwb3J0KTtcbiAgICAgICAgaWYgKHRoaXMubWFwLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0Wm9vbSh0aGlzLm9wdGlvbnMubWF4Wm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFwLnNldFpvb20odGhpcy5vcHRpb25zLm1heFpvb20pO1xuICAgICAgICB0aGlzLm1hcC5zZXRDZW50ZXIoZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgdGhpcy5tYXJrZXIuc2V0UG9zaXRpb24oZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICB0aGlzLm1hcmtlci5zZXRBbmltYXRpb24odGhpcy5vcHRpb25zLm1hcmtlck9wdGlvbnMuYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIHRoZSBlbGVtZW50cyBiYXNlZCBvbiBhIHNpbmdsZSBwbGFjZXMgb3IgZ2VvY29kaW5nIHJlc3BvbnNlXG4gICAgLy8gYW5kIHRyaWdnZXIgdGhlIFwiZ2VvY29kZTpyZXN1bHRcIiBldmVudCBvbiB0aGUgaW5wdXQuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUocmVzdWx0KSB7XG5cbiAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICB0aGlzLmNlbnRlcihyZXN1bHQuZ2VvbWV0cnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy4kZGV0YWlscykge1xuICAgICAgICB0aGlzLmZpbGxEZXRhaWxzKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcihcImdlb2NvZGU6cmVzdWx0XCIsIHJlc3VsdCk7XG4gICAgfSxcblxuICAgIC8vIFBvcHVsYXRlIHRoZSBwcm92aWRlZCBlbGVtZW50cyB3aXRoIG5ldyBgcmVzdWx0YCBkYXRhLlxuICAgIC8vIFRoaXMgd2lsbCBsb29rdXAgYWxsIGVsZW1lbnRzIHRoYXQgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlblxuICAgIC8vIGNvbXBvbmVudCB0eXBlLlxuICAgIGZpbGxEZXRhaWxzOiBmdW5jdGlvbiBmaWxsRGV0YWlscyhyZXN1bHQpIHtcblxuICAgICAgdmFyIGRhdGEgPSB7fSxcbiAgICAgICAgICBnZW9tZXRyeSA9IHJlc3VsdC5nZW9tZXRyeSxcbiAgICAgICAgICB2aWV3cG9ydCA9IGdlb21ldHJ5LnZpZXdwb3J0LFxuICAgICAgICAgIGJvdW5kcyA9IGdlb21ldHJ5LmJvdW5kcztcblxuICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBhZGRyZXNzIGNvbXBvbmVudHMuXG4gICAgICAkLmVhY2gocmVzdWx0LmFkZHJlc3NfY29tcG9uZW50cywgZnVuY3Rpb24gKGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBvYmplY3QudHlwZXNbMF07XG5cbiAgICAgICAgJC5lYWNoKG9iamVjdC50eXBlcywgZnVuY3Rpb24gKGluZGV4LCBuYW1lKSB7XG4gICAgICAgICAgZGF0YVtuYW1lXSA9IG9iamVjdC5sb25nX25hbWU7XG4gICAgICAgICAgZGF0YVtuYW1lICsgXCJfc2hvcnRcIl0gPSBvYmplY3Quc2hvcnRfbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgb2YgdGhlIHBsYWNlcyBkZXRhaWxzLlxuICAgICAgJC5lYWNoKHBsYWNlc0RldGFpbHMsIGZ1bmN0aW9uIChpbmRleCwga2V5KSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHJlc3VsdFtrZXldO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBpbmZvcyBhYm91dCB0aGUgYWRkcmVzcyBhbmQgZ2VvbWV0cnkuXG4gICAgICAkLmV4dGVuZChkYXRhLCB7XG4gICAgICAgIGZvcm1hdHRlZF9hZGRyZXNzOiByZXN1bHQuZm9ybWF0dGVkX2FkZHJlc3MsXG4gICAgICAgIGxvY2F0aW9uX3R5cGU6IGdlb21ldHJ5LmxvY2F0aW9uX3R5cGUgfHwgXCJQTEFDRVNcIixcbiAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgbG9jYXRpb246IGdlb21ldHJ5LmxvY2F0aW9uLFxuICAgICAgICBsYXQ6IGdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpLFxuICAgICAgICBsbmc6IGdlb21ldHJ5LmxvY2F0aW9uLmxuZygpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHRoZSB2YWx1ZXMgZm9yIGFsbCBkZXRhaWxzLlxuICAgICAgJC5lYWNoKHRoaXMuZGV0YWlscywgJC5wcm94eShmdW5jdGlvbiAoa2V5LCAkZGV0YWlsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgdGhpcy5zZXREZXRhaWwoJGRldGFpbCwgdmFsdWUpO1xuICAgICAgfSwgdGhpcykpO1xuXG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH0sXG5cbiAgICAvLyBBc3NpZ24gYSBnaXZlbiBgdmFsdWVgIHRvIGEgc2luZ2xlIGAkZWxlbWVudGAuXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgYW4gaW5wdXQsIHRoZSB2YWx1ZSBpcyBzZXQsIG90aGVyd2lzZSBpdCB1cGRhdGVzXG4gICAgLy8gdGhlIHRleHQgY29udGVudC5cbiAgICBzZXREZXRhaWw6IGZ1bmN0aW9uIHNldERldGFpbCgkZWxlbWVudCwgdmFsdWUpIHtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9VcmxWYWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VybFZhbHVlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkZWxlbWVudC5pcyhcIjppbnB1dFwiKSkge1xuICAgICAgICAkZWxlbWVudC52YWwodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsZW1lbnQudGV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEZpcmUgdGhlIFwiZ2VvY29kZTpkcmFnZ2VkXCIgZXZlbnQgYW5kIHBhc3MgdGhlIG5ldyBwb3NpdGlvbi5cbiAgICBtYXJrZXJEcmFnZ2VkOiBmdW5jdGlvbiBtYXJrZXJEcmFnZ2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJnZW9jb2RlOmRyYWdnZWRcIiwgZXZlbnQubGF0TG5nKTtcbiAgICB9LFxuXG4gICAgbWFwQ2xpY2tlZDogZnVuY3Rpb24gbWFwQ2xpY2tlZChldmVudCkge1xuICAgICAgdGhpcy50cmlnZ2VyKFwiZ2VvY29kZTpjbGlja1wiLCBldmVudC5sYXRMbmcpO1xuICAgIH0sXG5cbiAgICAvLyBGaXJlIHRoZSBcImdlb2NvZGU6bWFwZHJhZ2dlZFwiIGV2ZW50IGFuZCBwYXNzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBtYXAgY2VudGVyLlxuICAgIG1hcERyYWdnZWQ6IGZ1bmN0aW9uIG1hcERyYWdnZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImdlb2NvZGU6bWFwZHJhZ2dlZFwiLCB0aGlzLm1hcC5nZXRDZW50ZXIoKSk7XG4gICAgfSxcblxuICAgIC8vIEZpcmUgdGhlIFwiZ2VvY29kZTppZGxlXCIgZXZlbnQgYW5kIHBhc3MgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIG1hcCBjZW50ZXIuXG4gICAgbWFwSWRsZTogZnVuY3Rpb24gbWFwSWRsZShldmVudCkge1xuICAgICAgdGhpcy50cmlnZ2VyKFwiZ2VvY29kZTppZGxlXCIsIHRoaXMubWFwLmdldENlbnRlcigpKTtcbiAgICB9LFxuXG4gICAgbWFwWm9vbWVkOiBmdW5jdGlvbiBtYXBab29tZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImdlb2NvZGU6em9vbVwiLCB0aGlzLm1hcC5nZXRab29tKCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXN0b3JlIHRoZSBvbGQgcG9zaXRpb24gb2YgdGhlIG1hcmtlciB0byB0aGUgbGFzdCBrbndvbiBsb2NhdGlvbi5cbiAgICByZXNldE1hcmtlcjogZnVuY3Rpb24gcmVzZXRNYXJrZXIoKSB7XG4gICAgICB0aGlzLm1hcmtlci5zZXRQb3NpdGlvbih0aGlzLmRhdGEubG9jYXRpb24pO1xuICAgICAgdGhpcy5zZXREZXRhaWwodGhpcy5kZXRhaWxzLmxhdCwgdGhpcy5kYXRhLmxvY2F0aW9uLmxhdCgpKTtcbiAgICAgIHRoaXMuc2V0RGV0YWlsKHRoaXMuZGV0YWlscy5sbmcsIHRoaXMuZGF0YS5sb2NhdGlvbi5sbmcoKSk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgcGx1Z2luIGFmdGVyIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCBhbiBhdXRvY29tcGxldGUgZW50cnkuXG4gICAgLy8gSWYgdGhlIHBsYWNlIGhhcyBubyBnZW9tZXRyeSBpdCBwYXNzZXMgaXQgdG8gdGhlIGdlb2NvZGVyLlxuICAgIHBsYWNlQ2hhbmdlZDogZnVuY3Rpb24gcGxhY2VDaGFuZ2VkKCkge1xuICAgICAgdmFyIHBsYWNlID0gdGhpcy5hdXRvY29tcGxldGUuZ2V0UGxhY2UoKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIXBsYWNlLmdlb21ldHJ5KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b3NlbGVjdCkge1xuICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgaGlnaGxpZ2h0ZWQgaXRlbSBvciB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZVxuICAgICAgICAgIC8vIHN1Z2dlc3Rpb25zIGxpc3QuXG4gICAgICAgICAgdmFyIGF1dG9TZWxlY3Rpb24gPSB0aGlzLnNlbGVjdEZpcnN0UmVzdWx0KCk7XG4gICAgICAgICAgdGhpcy5maW5kKGF1dG9TZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGlucHV0IHRleHQgaWYgaXQgYWxyZWFkeSBnaXZlcyBnZW9tZXRyeS5cbiAgICAgICAgdGhpcy51cGRhdGUocGxhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQSBwbHVnaW4gd3JhcHBlciBhcm91bmQgdGhlIGNvbnN0cnVjdG9yLlxuICAvLyBQYXNzIGBvcHRpb25zYCB3aXRoIGFsbCBzZXR0aW5ncyB0aGF0IGFyZSBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdC5cbiAgLy8gVGhlIGF0dHJpYnV0ZSBpcyB1c2VkIHRvIHByZXZlbnQgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnMgb2YgdGhlIHBsdWdpbi5cbiAgJC5mbi5nZW9jb21wbGV0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICB2YXIgYXR0cmlidXRlID0gJ3BsdWdpbl9nZW9jb21wbGV0ZSc7XG5cbiAgICAvLyBJZiB5b3UgY2FsbCBgLmdlb2NvbXBsZXRlKClgIHdpdGggYSBzdHJpbmcgYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxuICAgIC8vIGl0IHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgb3IgY2FsbHMgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICAgIC8vIGZvbGxvd2luZyBhcmd1bWVudHMuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwic3RyaW5nXCIpIHtcblxuICAgICAgdmFyIGluc3RhbmNlID0gJCh0aGlzKS5kYXRhKGF0dHJpYnV0ZSkgfHwgJCh0aGlzKS5nZW9jb21wbGV0ZSgpLmRhdGEoYXR0cmlidXRlKSxcbiAgICAgICAgICBwcm9wID0gaW5zdGFuY2Vbb3B0aW9uc107XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJvcC5hcHBseShpbnN0YW5jZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIHJldHVybiAkKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgIHByb3AgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcmV2ZW50IGFnYWluc3QgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnMuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9ICQuZGF0YSh0aGlzLCBhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBuZXcgR2VvQ29tcGxldGUodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgJC5kYXRhKHRoaXMsIGF0dHJpYnV0ZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2phdmFzY3JpcHQvcGFja3MvanF1ZXJ5Lmdlb2NvbXBsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ })

/******/ });